<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{{ site_name }} - Live Stream</title>
    <link rel="icon" type="image/svg+xml" href="/static/images/favicon.svg" />
    <link rel="stylesheet" href="/static/style.css" />
    <style>
      .stream-container {
        display: grid;
        grid-template-columns: 1fr;
        gap: 2rem;
        margin-bottom: 2rem;
      }

      @media (min-width: 1024px) {
        .stream-container {
          grid-template-columns: 1fr 1fr;
        }
      }

      .spectrogram-card {
        min-height: 500px;
      }

      .audio-card {
        min-height: 300px;
      }

      #spectrogramCanvas {
        width: 100%;
        height: 400px;
        background-color: #000;
        border-radius: 8px;
        border: 1px solid var(--border-color);
      }

      .controls-row {
        display: flex;
        gap: 1rem;
        align-items: center;
        flex-wrap: wrap;
        margin-bottom: 1rem;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .control-group label {
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .control-group input[type="range"] {
        width: 100px;
      }

      .control-group input[type="number"] {
        width: 80px;
        padding: 0.25rem 0.5rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background-color: var(--background);
        color: var(--text);
      }

      .status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 1rem;
        margin-bottom: 1.5rem;
      }

      .status-indicator {
        padding: 0.75rem 1rem;
        border-radius: 8px;
        text-align: center;
        font-weight: 500;
        font-size: 0.875rem;
        border: 1px solid var(--border-color);
      }

      .status-connected {
        background-color: rgba(34, 197, 94, 0.1);
        border-color: #22c55e;
        color: #15803d;
      }

      .status-disconnected {
        background-color: rgba(239, 68, 68, 0.1);
        border-color: #ef4444;
        color: #dc2626;
      }

      .status-info {
        background-color: rgba(59, 130, 246, 0.1);
        border-color: #3b82f6;
        color: #2563eb;
      }

      .connection-controls {
        display: flex;
        gap: 1rem;
        align-items: center;
        margin-bottom: 1.5rem;
        flex-wrap: wrap;
      }

      .audio-controls-inline {
        display: flex;
        gap: 1rem;
        align-items: center;
        padding: 0.5rem 1rem;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background-color: rgba(0, 0, 0, 0.02);
      }

      .btn-disconnect {
        background-color: var(--error-color);
        border-color: var(--error-color);
      }

      .btn-disconnect:hover:not(:disabled) {
        background-color: var(--error-color);
        opacity: 0.9;
      }

      .livestream-audio-controls {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        margin-top: 1rem;
      }

      .audio-volume-control {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .audio-volume-control label {
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .audio-volume-control input[type="range"] {
        flex: 1;
        max-width: 150px;
      }

      .audio-volume-control span {
        font-size: 0.875rem;
        color: var(--text-secondary);
        min-width: 40px;
      }

      .frequency-labels {
        display: flex;
        justify-content: space-between;
        margin-top: 0.5rem;
        font-size: 0.75rem;
        color: var(--text-secondary);
      }

      .messages-container {
        max-height: 200px;
        overflow-y: auto;
        background-color: rgba(0, 0, 0, 0.05);
        border-radius: 8px;
        padding: 1rem;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 0.875rem;
      }

      .message {
        margin-bottom: 0.25rem;
        color: var(--text-secondary);
      }

      .message:last-child {
        margin-bottom: 0;
      }

      .detections-container {
        max-height: 300px;
        overflow-y: auto;
        background-color: rgba(0, 0, 0, 0.02);
        border-radius: 8px;
        padding: 1rem;
      }

      .detection-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem;
        margin-bottom: 0.5rem;
        border-radius: 6px;
        background-color: var(--background);
        border: 1px solid var(--border-color);
      }

      .detection-item:last-child {
        margin-bottom: 0;
      }

      .detection-info {
        flex: 1;
      }

      .detection-species {
        font-weight: 600;
        color: var(--text);
      }

      .detection-confidence {
        font-size: 0.875rem;
        color: var(--text-secondary);
      }

      .detection-time {
        font-size: 0.875rem;
        color: var(--text-secondary);
        white-space: nowrap;
        margin-left: 1rem;
      }

      .no-detections {
        color: var(--text-secondary);
        text-align: center;
        font-style: italic;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <!-- Navigation -->
    <div class="dashboard" style="padding-top: 2rem">
      <div class="section-header">
        <h1 class="section-title">Live Stream</h1>
        <p class="section-subtitle">
          Real-time audio stream and visual spectrogram analysis
        </p>
        <div style="margin-top: 1rem">
          <a href="/" class="btn btn-secondary" style="margin-right: 1rem">
            <span>üè†</span> Back to Dashboard
          </a>
          <a href="/field" class="btn btn-secondary">
            <span>üì±</span> Field Mode
          </a>
        </div>
      </div>

      <!-- Connection Status -->
      <div class="dashboard-card" style="margin-bottom: 2rem">
        <div class="card-header">
          <h3 class="card-title">Connection Status</h3>
        </div>
        <div class="card-content">
          <div class="status-grid">
            <div id="audioStatus" class="status-indicator status-disconnected">
              Audio: Disconnected
            </div>
            <div id="spectrogramStatus" class="status-indicator status-disconnected">
              Spectrogram: Disconnected
            </div>
            <div id="updateRate" class="status-indicator status-info">
              Updates: 0 Hz
            </div>
            <div id="latency" class="status-indicator status-info">
              Latency: -- ms
            </div>
          </div>

          <div class="connection-controls">
            <button id="audioToggleBtn" class="btn btn-primary" onclick="toggleAudioConnection()">
              <span id="audioToggleIcon">üéµ</span> <span id="audioToggleText">Connect Audio</span>
            </button>
            <button id="spectrogramToggleBtn" class="btn btn-primary" onclick="toggleSpectrogramConnection()">
              <span id="spectrogramToggleIcon">üìä</span> <span id="spectrogramToggleText">Connect Spectrogram</span>
            </button>
            
            <!-- Audio Controls -->
            <div class="audio-controls-inline" id="audioControlsInline" style="display: none;">
              <button id="audioPlayBtn" class="btn btn-success" onclick="toggleAudioPlayback()" disabled>
                <span id="audioPlayIcon">üîä</span> <span id="audioPlayText">Audio On</span>
              </button>
              <div class="audio-volume-control">
                <label for="audioVolume">Volume:</label>
                <input type="range" id="audioVolume" min="0" max="100" value="60" onchange="updateAudioVolume(this.value)">
                <span id="volumeDisplay">60%</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Live Streams -->
      <div class="stream-container">
        <!-- Spectrogram Card -->
        <div class="dashboard-card spectrogram-card">
          <div class="card-header">
            <h3 class="card-title">Live Spectrogram</h3>
            <span class="card-badge badge-info">Real-time</span>
          </div>
          <div class="card-content">
            <div class="controls-row">
              <div class="control-group">
                <label for="colorScale">Color Scale</label>
                <input
                  type="range"
                  id="colorScale"
                  min="1"
                  max="100"
                  value="50"
                  onchange="updateColorScale(this.value)"
                />
              </div>
              <div class="control-group">
                <label for="maxFreq">Max Freq (Hz)</label>
                <input
                  type="number"
                  id="maxFreq"
                  value="12000"
                  min="1000"
                  max="24000"
                  step="500"
                  onchange="updateFrequencyRange()"
                />
              </div>
              <div class="control-group">
                <label for="timeWindow">Time Window (s)</label>
                <input
                  type="number"
                  id="timeWindow"
                  value="10"
                  min="5"
                  max="60"
                  step="5"
                  onchange="updateTimeWindow(this.value)"
                />
              </div>
            </div>

            <canvas id="spectrogramCanvas"></canvas>
            <div class="frequency-labels">
              <span>0 Hz</span>
              <span id="midFreqLabel">6 kHz</span>
              <span id="maxFreqLabel">12 kHz</span>
            </div>
          </div>
        </div>

        <!-- Live Detections Card -->
        <div class="dashboard-card detections-card">
          <div class="card-header">
            <h3 class="card-title">Live Detections</h3>
            <span class="card-badge badge-info" id="detectionCount">0 detected</span>
          </div>
          <div class="card-content">
            <div id="liveDetections" class="detections-container">
              <p class="no-detections">No detections yet. Start streaming to see bird detections in real-time.</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Connection Log Card -->
      <div class="dashboard-card" style="margin-bottom: 2rem;">
        <div class="card-header">
          <h3 class="card-title">Connection Log</h3>
        </div>
        <div class="card-content">
          <div id="messages" class="messages-container"></div>
        </div>
      </div>
    </div>

    <script>
      // WebSocket connections
      let audioWs = null;
      let spectrogramWs = null;

      // Canvas and drawing context
      const canvas = document.getElementById("spectrogramCanvas");
      const ctx = canvas.getContext("2d");

      // Set canvas size
      function resizeCanvas() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth - 32; // Account for padding
        canvas.height = 400;
        drawSpectrogram(); // Redraw when resized
      }

      // Spectrogram configuration
      let config = {
        sample_rate: 48000,
        window_size: 1024,
        freq_bins: [],
        update_rate: 15.0,
      };

      // Display parameters
      let maxFrequency = 12000;
      let timeWindow = 10; // seconds
      let colorScale = 50;

      // Data storage
      let spectrogramHistory = [];
      let lastUpdateTime = 0;
      let updateCount = 0;
      let startTime = Date.now();

      // UI elements
      const elements = {
        audioStatus: document.getElementById("audioStatus"),
        spectrogramStatus: document.getElementById("spectrogramStatus"),
        updateRate: document.getElementById("updateRate"),
        latency: document.getElementById("latency"),
        audioToggleBtn: document.getElementById("audioToggleBtn"),
        audioToggleIcon: document.getElementById("audioToggleIcon"),
        audioToggleText: document.getElementById("audioToggleText"),
        spectrogramToggleBtn: document.getElementById("spectrogramToggleBtn"),
        spectrogramToggleIcon: document.getElementById("spectrogramToggleIcon"),
        spectrogramToggleText: document.getElementById("spectrogramToggleText"),
        audioControlsInline: document.getElementById("audioControlsInline"),
        messages: document.getElementById("messages"),
        audioPlayBtn: document.getElementById("audioPlayBtn"),
        audioPlayIcon: document.getElementById("audioPlayIcon"),
        audioPlayText: document.getElementById("audioPlayText"),
        audioVolume: document.getElementById("audioVolume"),
        volumeDisplay: document.getElementById("volumeDisplay"),
        liveDetections: document.getElementById("liveDetections"),
        detectionCount: document.getElementById("detectionCount"),
        maxFreqLabel: document.getElementById("maxFreqLabel"),
        midFreqLabel: document.getElementById("midFreqLabel"),
      };

      // Detection tracking
      let detectionsList = [];
      let notificationsWs = null;

      function addMessage(message) {
        const messageDiv = document.createElement("div");
        messageDiv.className = "message";
        messageDiv.textContent =
          new Date().toLocaleTimeString() + ": " + message;
        elements.messages.appendChild(messageDiv);
        elements.messages.scrollTop = elements.messages.scrollHeight;
      }

      function updateStatus(element, connected, text) {
        element.textContent = text;
        element.className = `status-indicator ${
          connected ? "status-connected" : "status-disconnected"
        }`;
      }

      function connect() {
        // Legacy function - now connects both streams independently
        connectAudio();
        connectSpectrogram();
      }

      function toggleAudioConnection() {
        const isConnected = audioWs && audioWs.readyState === WebSocket.OPEN;
        if (isConnected) {
          disconnectAudio();
        } else {
          connectAudio();
        }
      }

      function toggleSpectrogramConnection() {
        const isConnected = spectrogramWs && spectrogramWs.readyState === WebSocket.OPEN;
        if (isConnected) {
          disconnectSpectrogram();
        } else {
          connectSpectrogram();
        }
      }

      function connectAudio() {
        if (audioWs && audioWs.readyState === WebSocket.OPEN) {
          addMessage("Audio already connected");
          return;
        }

        elements.audioToggleBtn.disabled = true;
        elements.audioToggleText.textContent = "Connecting...";
        addMessage("Connecting to audio stream...");

        const wsProtocol = location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${wsProtocol}//${location.host}/ws/audio`;
        
        audioWs = new WebSocket(wsUrl);

        audioWs.onopen = function (event) {
          updateStatus(elements.audioStatus, true, "Audio: Connected");
          addMessage("Audio WebSocket connected");
          elements.audioToggleBtn.disabled = false;
          elements.audioToggleBtn.className = "btn btn-disconnect";
          elements.audioToggleIcon.textContent = "üîá";
          elements.audioToggleText.textContent = "Disconnect Audio";
          elements.audioControlsInline.style.display = "flex";
          elements.audioPlayBtn.disabled = false;
        };

        audioWs.onmessage = function (event) {
          if (event.data instanceof ArrayBuffer) {
            // Convert ArrayBuffer to Blob for MP3 audio data
            const audioBlob = new Blob([event.data], { type: 'audio/mpeg' });
            handleAudioData(audioBlob);
          } else if (event.data instanceof Blob) {
            handleAudioData(event.data);
          } else {
            addMessage("Audio: " + event.data);
          }
        };

        audioWs.onclose = function (event) {
          updateStatus(elements.audioStatus, false, "Audio: Disconnected");
          addMessage(`Audio WebSocket disconnected: ${event.code}`);
          elements.audioToggleBtn.disabled = false;
          elements.audioToggleBtn.className = "btn btn-primary";
          elements.audioToggleIcon.textContent = "üéµ";
          elements.audioToggleText.textContent = "Connect Audio";
          elements.audioControlsInline.style.display = "none";
          elements.audioPlayBtn.disabled = true;
        };

        audioWs.onerror = function (error) {
          updateStatus(elements.audioStatus, false, "Audio: Error");
          addMessage("Audio WebSocket error");
          elements.audioToggleBtn.disabled = false;
          elements.audioToggleBtn.className = "btn btn-primary";
          elements.audioToggleIcon.textContent = "üéµ";
          elements.audioToggleText.textContent = "Connect Audio";
          elements.audioControlsInline.style.display = "none";
          elements.audioPlayBtn.disabled = true;
        };
      }

      function disconnectAudio() {
        if (audioWs) {
          audioWs.close();
          audioWs = null;
        }
        
        // Stop current audio playback
        if (currentAudio && !currentAudio.ended) {
          currentAudio.pause();
          currentAudio.currentTime = 0;
        }
        
        elements.audioToggleBtn.disabled = false;
        elements.audioToggleBtn.className = "btn btn-primary";
        elements.audioToggleIcon.textContent = "üéµ";
        elements.audioToggleText.textContent = "Connect Audio";
        elements.audioControlsInline.style.display = "none";
        elements.audioPlayBtn.disabled = true;
        addMessage("Disconnected from audio stream");
      }

      function connectSpectrogram() {
        if (spectrogramWs && spectrogramWs.readyState === WebSocket.OPEN) {
          addMessage("Spectrogram already connected");
          return;
        }

        elements.spectrogramToggleBtn.disabled = true;
        elements.spectrogramToggleText.textContent = "Connecting...";
        addMessage("Connecting to spectrogram stream...");

        // Reset counters when connecting spectrogram
        updateCount = 0;
        startTime = Date.now();
        lastUpdateTime = 0;

        const wsProtocol = location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${wsProtocol}//${location.host}/ws/spectrogram`;
        
        spectrogramWs = new WebSocket(wsUrl);

        spectrogramWs.onopen = function (event) {
          updateStatus(elements.spectrogramStatus, true, "Spectrogram: Connected");
          addMessage("Spectrogram WebSocket connected");
          elements.spectrogramToggleBtn.disabled = false;
          elements.spectrogramToggleBtn.className = "btn btn-disconnect";
          elements.spectrogramToggleIcon.textContent = "üö´";
          elements.spectrogramToggleText.textContent = "Disconnect Spectrogram";
        };

        spectrogramWs.onmessage = function (event) {
          try {
            const data = JSON.parse(event.data);
            if (data.type === "config") {
              handleSpectrogramConfig(data);
            } else if (data.type === "spectrogram") {
              handleSpectrogramData(data);
            }
          } catch (e) {
            addMessage("Spectrogram: " + event.data);
          }
        };

        spectrogramWs.onclose = function (event) {
          updateStatus(elements.spectrogramStatus, false, "Spectrogram: Disconnected");
          addMessage(`Spectrogram WebSocket disconnected: ${event.code}`);
          elements.spectrogramToggleBtn.disabled = false;
          elements.spectrogramToggleBtn.className = "btn btn-primary";
          elements.spectrogramToggleIcon.textContent = "üìä";
          elements.spectrogramToggleText.textContent = "Connect Spectrogram";
        };

        spectrogramWs.onerror = function (error) {
          updateStatus(elements.spectrogramStatus, false, "Spectrogram: Error");
          addMessage("Spectrogram WebSocket error");
          elements.spectrogramToggleBtn.disabled = false;
          elements.spectrogramToggleBtn.className = "btn btn-primary";
          elements.spectrogramToggleIcon.textContent = "üìä";
          elements.spectrogramToggleText.textContent = "Connect Spectrogram";
        };
      }

      function disconnectSpectrogram() {
        if (spectrogramWs) {
          spectrogramWs.close();
          spectrogramWs = null;
        }

        // Clear the canvas and data
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        spectrogramHistory = [];

        elements.spectrogramToggleBtn.disabled = false;
        elements.spectrogramToggleBtn.className = "btn btn-primary";
        elements.spectrogramToggleIcon.textContent = "üìä";
        elements.spectrogramToggleText.textContent = "Connect Spectrogram";
        addMessage("Disconnected from spectrogram stream");
      }

      function disconnect() {
        // Legacy function - now disconnects both streams
        disconnectAudio();
        disconnectSpectrogram();
        addMessage("Disconnected from all streams");
      }

      // Audio player management
      let audioEnabled = true;
      let audioVolume = 0.6;
      let currentAudio = null;

      function handleAudioData(audioBlob) {
        if (!audioEnabled) {
          return;
        }
        
        // Stop previous audio if still playing to prevent overlap
        if (currentAudio && !currentAudio.ended) {
          currentAudio.pause();
          currentAudio.currentTime = 0;
        }
        
        // Create and play new audio chunk immediately for real-time streaming
        const audioUrl = URL.createObjectURL(audioBlob);
        currentAudio = new Audio(audioUrl);
        currentAudio.volume = audioVolume;
        
        currentAudio.play().catch((e) => {
          console.log("Audio play error:", e);
        });

        // Clean up the blob URL after playback
        currentAudio.addEventListener("ended", () => {
          URL.revokeObjectURL(audioUrl);
        });
      }

      function toggleAudioPlayback() {
        audioEnabled = !audioEnabled;
        
        if (audioEnabled) {
          elements.audioPlayIcon.textContent = "üîä";
          elements.audioPlayText.textContent = "Audio On";
          elements.audioPlayBtn.className = "btn btn-success";
          addMessage("Audio playback enabled");
        } else {
          elements.audioPlayIcon.textContent = "üîá";
          elements.audioPlayText.textContent = "Audio Off";  
          elements.audioPlayBtn.className = "btn btn-secondary";
          
          // Stop current audio
          if (currentAudio && !currentAudio.ended) {
            currentAudio.pause();
            currentAudio.currentTime = 0;
          }
          addMessage("Audio playback disabled");
        }
      }

      function updateAudioVolume(value) {
        audioVolume = value / 100;
        elements.volumeDisplay.textContent = value + "%";
        
        // Update current audio if playing
        if (currentAudio) {
          currentAudio.volume = audioVolume;
        }
      }

      // Setup audio controls
      function setupAudioPlayerControls() {
        // Enable audio play button when audio is connected
        // (this will be called from connectAudio function)
      }

      // Detection management
      function addDetection(detection) {
        const timestamp = new Date().toLocaleTimeString();
        
        const detectionItem = {
          species: detection.species || detection.common_name || 'Unknown Species',
          confidence: detection.confidence || 0,
          timestamp: timestamp,
          id: Date.now() + Math.random()
        };
        
        detectionsList.unshift(detectionItem); // Add to beginning
        
        // Limit to 50 detections
        if (detectionsList.length > 50) {
          detectionsList = detectionsList.slice(0, 50);
        }
        
        updateDetectionDisplay();
        updateDetectionCount();
      }

      function updateDetectionDisplay() {
        const container = elements.liveDetections;
        
        if (detectionsList.length === 0) {
          container.innerHTML = '<p class="no-detections">No detections yet. Start streaming to see bird detections in real-time.</p>';
          return;
        }
        
        const html = detectionsList.map(detection => `
          <div class="detection-item">
            <div class="detection-info">
              <div class="detection-species">${detection.species}</div>
              <div class="detection-confidence">${(detection.confidence * 100).toFixed(1)}% confidence</div>
            </div>
            <div class="detection-time">${detection.timestamp}</div>
          </div>
        `).join('');
        
        container.innerHTML = html;
      }

      function updateDetectionCount() {
        const count = detectionsList.length;
        elements.detectionCount.textContent = `${count} detected`;
      }

      // Connect to notifications WebSocket for detections
      function connectNotifications() {
        const wsProtocol = location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${wsProtocol}//${location.host}/ws/notifications`;
        
        notificationsWs = new WebSocket(wsUrl);
        
        notificationsWs.onopen = function(event) {
          addMessage("Notifications WebSocket connected");
        };
        
        notificationsWs.onmessage = function(event) {
          try {
            const data = JSON.parse(event.data);
            
            // Handle detection notifications
            if (data.type === 'detection' && data.detection) {
              addDetection(data.detection);
              addMessage(`Detected: ${data.detection.species || data.detection.common_name}`);
            }
          } catch (e) {
            console.log("Notifications message:", event.data);
          }
        };
        
        notificationsWs.onclose = function(event) {
          addMessage("Notifications WebSocket disconnected");
          // Auto-reconnect after a delay
          setTimeout(connectNotifications, 5000);
        };
        
        notificationsWs.onerror = function(error) {
          addMessage("Notifications WebSocket error");
        };
      }

      function handleSpectrogramConfig(configData) {
        config = configData;
        addMessage(`Spectrogram config: ${config.sample_rate}Hz, window=${config.window_size}`);
        updateFrequencyLabels();
      }

      function handleSpectrogramData(data) {
        const now = Date.now();

        // Calculate update rate and latency
        updateCount++;
        const elapsedTime = (now - startTime) / 1000;
        if (elapsedTime > 0) {
          const currentUpdateRate = updateCount / elapsedTime;
          elements.updateRate.textContent = `Updates: ${currentUpdateRate.toFixed(1)} Hz`;
        }

        if (lastUpdateTime > 0 && data.timestamp) {
          const latency = now - data.timestamp * 1000;
          elements.latency.textContent = `Latency: ${Math.round(Math.abs(latency))} ms`;
        }
        lastUpdateTime = now;

        // Store spectrogram data
        spectrogramHistory.push({
          data: data.data,
          timestamp: now,
        });

        // Limit history based on time window
        const cutoffTime = now - timeWindow * 1000;
        spectrogramHistory = spectrogramHistory.filter(
          (item) => item.timestamp > cutoffTime
        );

        // Draw the spectrogram
        drawSpectrogram();
      }

      function drawSpectrogram() {
        if (spectrogramHistory.length === 0) return;

        const width = canvas.width;
        const height = canvas.height;

        // Clear canvas with dark background
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, width, height);

        // Calculate dimensions
        const timeSlices = spectrogramHistory.length;
        if (timeSlices === 0) return;
        
        const sliceWidth = width / timeSlices;

        // Get the frequency range to display
        const maxFreqIndex = config.freq_bins.length > 0 ? 
          Math.floor((maxFrequency / (config.sample_rate / 2)) * config.freq_bins.length) : 
          spectrogramHistory[0].data.length;

        spectrogramHistory.forEach((item, timeIndex) => {
          const spectrogramData = item.data;
          if (!spectrogramData || !Array.isArray(spectrogramData)) return;
          
          const freqBins = Math.min(spectrogramData.length, maxFreqIndex);

          for (let freqIndex = 0; freqIndex < freqBins; freqIndex++) {
            const magnitude = spectrogramData[freqIndex];

            // Convert magnitude to color intensity
            const normalizedMagnitude = Math.max(0, Math.min(1, 
              ((magnitude + 60) / 60) * (colorScale / 50) // Assuming -60dB to 0dB range
            ));

            // Create color gradient (blue -> green -> yellow -> red)
            let r, g, b;
            if (normalizedMagnitude < 0.25) {
              r = 0;
              g = 0;
              b = Math.floor(255 * (normalizedMagnitude * 4));
            } else if (normalizedMagnitude < 0.5) {
              r = 0;
              g = Math.floor(255 * ((normalizedMagnitude - 0.25) * 4));
              b = 255;
            } else if (normalizedMagnitude < 0.75) {
              r = Math.floor(255 * ((normalizedMagnitude - 0.5) * 4));
              g = 255;
              b = Math.floor(255 * (1 - (normalizedMagnitude - 0.5) * 4));
            } else {
              r = 255;
              g = Math.floor(255 * (1 - (normalizedMagnitude - 0.75) * 4));
              b = 0;
            }

            ctx.fillStyle = `rgb(${r},${g},${b})`;

            // Draw rectangle (frequency is inverted - high frequencies at top)
            const x = timeIndex * sliceWidth;
            const y = height - ((freqIndex + 1) / freqBins) * height;
            const rectHeight = Math.max(1, height / freqBins);

            ctx.fillRect(x, y, Math.ceil(sliceWidth), Math.ceil(rectHeight));
          }
        });
      }

      function updateColorScale(value) {
        colorScale = parseInt(value);
        drawSpectrogram();
      }

      function updateFrequencyRange() {
        const newMaxFreq = parseInt(document.getElementById("maxFreq").value);
        maxFrequency = Math.min(newMaxFreq, config.sample_rate / 2);
        updateFrequencyLabels();
        drawSpectrogram();
      }

      function updateTimeWindow(value) {
        timeWindow = parseInt(value);
        // Clear old data that's outside the new window
        const now = Date.now();
        const cutoffTime = now - timeWindow * 1000;
        spectrogramHistory = spectrogramHistory.filter(
          (item) => item.timestamp > cutoffTime
        );
        drawSpectrogram();
      }

      function updateFrequencyLabels() {
        elements.maxFreqLabel.textContent = `${(maxFrequency / 1000).toFixed(1)} kHz`;
        elements.midFreqLabel.textContent = `${(maxFrequency / 2000).toFixed(1)} kHz`;
      }

      // Initialize
      window.addEventListener("load", function () {
        resizeCanvas();
        updateFrequencyLabels();
        setupAudioPlayerControls();
        connectNotifications();
        addMessage("Page loaded. Use individual Connect buttons to start audio and/or spectrogram streaming.");
      });

      // Handle window resize
      window.addEventListener("resize", resizeCanvas);

      // Handle page visibility changes
      document.addEventListener("visibilitychange", function () {
        if (document.hidden) {
          addMessage("Page hidden - maintaining connections");
        } else if (!document.hidden) {
          addMessage("Page visible - connections active");
          // Redraw in case canvas was cleared
          if (spectrogramHistory.length > 0) {
            drawSpectrogram();
          }
        }
      });

      // Keep connections alive
      setInterval(() => {
        if (audioWs && audioWs.readyState === WebSocket.OPEN) {
          audioWs.send("ping");
        }
        if (spectrogramWs && spectrogramWs.readyState === WebSocket.OPEN) {
          spectrogramWs.send("ping");
        }
      }, 30000);
    </script>
  </body>
</html>