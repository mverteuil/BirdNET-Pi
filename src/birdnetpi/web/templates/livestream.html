<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{{ site_name }} - Live Stream</title>
    <link rel="icon" type="image/svg+xml" href="/static/images/favicon.svg" />
    <link rel="stylesheet" href="/static/style.css" />
    <style>
      .stream-container {
        display: grid;
        grid-template-columns: 1fr;
        gap: 2rem;
        margin-bottom: 2rem;
      }

      .spectrogram-card {
        order: 1; /* Show spectrogram first */
      }

      .detections-card {
        order: 2; /* Show detections below spectrogram */
      }

      .spectrogram-card {
        min-height: 500px;
      }

      .audio-card {
        min-height: 300px;
      }

      #spectrogramCanvas {
        width: 100%;
        height: 400px;
        background-color: #fff;
        border-radius: 8px;
        border: 1px solid var(--border-color);
      }

      .controls-row {
        display: flex;
        gap: 1rem;
        align-items: center;
        flex-wrap: wrap;
        margin-bottom: 1rem;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .control-group label {
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .control-group input[type="range"] {
        width: 100px;
      }

      .control-group input[type="number"] {
        width: 80px;
        padding: 0.25rem 0.5rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background-color: var(--background);
        color: var(--text);
      }

      .status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 1rem;
        margin-bottom: 1.5rem;
      }

      .status-indicator {
        padding: 0.75rem 1rem;
        border-radius: 8px;
        text-align: center;
        font-weight: 500;
        font-size: 0.875rem;
        border: 1px solid var(--border-color);
      }

      .status-connected {
        background-color: rgba(34, 197, 94, 0.1);
        border-color: #22c55e;
        color: #15803d;
      }

      .status-disconnected {
        background-color: rgba(239, 68, 68, 0.1);
        border-color: #ef4444;
        color: #dc2626;
      }

      .status-info {
        background-color: rgba(59, 130, 246, 0.1);
        border-color: #3b82f6;
        color: #2563eb;
      }

      .connection-controls {
        display: flex;
        gap: 1rem;
        align-items: center;
        margin-bottom: 1.5rem;
        flex-wrap: wrap;
      }

      .audio-controls-inline {
        display: flex;
        gap: 1rem;
        align-items: center;
        padding: 0.5rem 1rem;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background-color: rgba(0, 0, 0, 0.02);
      }

      .btn-disconnect {
        background-color: var(--error-color);
        border-color: var(--error-color);
      }

      .btn-disconnect:hover:not(:disabled) {
        background-color: var(--error-color);
        opacity: 0.9;
      }

      .livestream-audio-controls {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        margin-top: 1rem;
      }

      .audio-volume-control {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .audio-volume-control label {
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-secondary);
      }

      .audio-volume-control input[type="range"] {
        flex: 1;
        max-width: 150px;
      }

      .audio-volume-control span {
        font-size: 0.875rem;
        color: var(--text-secondary);
        min-width: 40px;
      }

      .frequency-labels {
        position: absolute;
        height: 400px; /* Match canvas height */
        width: 60px;
        left: 0px; /* Align with canvas left edge */
        top: 0;
        font-size: 0.75rem;
        color: var(--text-secondary);
        pointer-events: none; /* Allow clicks through to canvas */
      }

      .freq-label-top {
        position: absolute;
        top: 0;
        left: 5px;
        transform: translateY(-50%);
        background: rgba(255, 255, 255, 0.8);
        padding: 2px 4px;
        border-radius: 3px;
      }

      .freq-label-mid {
        position: absolute;
        top: 50%;
        left: 5px;
        transform: translateY(-50%);
        background: rgba(255, 255, 255, 0.8);
        padding: 2px 4px;
        border-radius: 3px;
      }

      .freq-label-bottom {
        position: absolute;
        bottom: 0;
        left: 5px;
        transform: translateY(50%);
        background: rgba(255, 255, 255, 0.8);
        padding: 2px 4px;
        border-radius: 3px;
      }

      .messages-container {
        max-height: 200px;
        overflow-y: auto;
        background-color: rgba(0, 0, 0, 0.05);
        border-radius: 8px;
        padding: 1rem;
        font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
        font-size: 0.875rem;
      }

      .message {
        margin-bottom: 0.25rem;
        color: var(--text-secondary);
      }

      .message:last-child {
        margin-bottom: 0;
      }

      .detections-container {
        max-height: 300px;
        overflow-y: auto;
        background-color: rgba(0, 0, 0, 0.02);
        border-radius: 8px;
        padding: 1rem;
      }

      .detection-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem;
        margin-bottom: 0.5rem;
        border-radius: 6px;
        background-color: var(--background);
        border: 1px solid var(--border-color);
      }

      .detection-item:last-child {
        margin-bottom: 0;
      }

      .detection-info {
        flex: 1;
      }

      .detection-species {
        font-weight: 600;
        color: var(--text);
      }

      .detection-confidence {
        font-size: 0.875rem;
        color: var(--text-secondary);
      }

      .detection-time {
        font-size: 0.875rem;
        color: var(--text-secondary);
        white-space: nowrap;
        margin-left: 1rem;
      }

      .no-detections {
        color: var(--text-secondary);
        text-align: center;
        font-style: italic;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <!-- Navigation -->
    <div class="dashboard" style="padding-top: 2rem">
      <div class="section-header">
        <h1 class="section-title">Live Stream</h1>
        <p class="section-subtitle">
          Real-time audio stream and visual spectrogram analysis
        </p>
        <div style="margin-top: 1rem">
          <a href="/" class="btn btn-secondary" style="margin-right: 1rem">
            <span>üè†</span> Back to Dashboard
          </a>
          <a href="/field" class="btn btn-secondary">
            <span>üì±</span> Field Mode
          </a>
        </div>
      </div>

      <!-- Connection Status -->
      <div class="dashboard-card" style="margin-bottom: 2rem">
        <div class="card-header">
          <h3 class="card-title">Connection Status</h3>
        </div>
        <div class="card-content">
          <div class="status-grid">
            <div id="audioStatus" class="status-indicator status-disconnected">
              Audio: Disconnected
            </div>
            <div
              id="spectrogramStatus"
              class="status-indicator status-disconnected"
            >
              Spectrogram: Disconnected
            </div>
            <div id="updateRate" class="status-indicator status-info">
              Updates: 0 Hz
            </div>
            <div id="latency" class="status-indicator status-info">
              Latency: -- ms
            </div>
          </div>

          <div class="connection-controls">
            <button
              id="audioToggleBtn"
              class="btn btn-primary"
              onclick="toggleAudioConnection()"
            >
              <span id="audioToggleIcon">üéµ</span>
              <span id="audioToggleText">Connect Audio</span>
            </button>
            <button
              id="spectrogramToggleBtn"
              class="btn btn-primary"
              onclick="toggleSpectrogramConnection()"
            >
              <span id="spectrogramToggleIcon">üìä</span>
              <span id="spectrogramToggleText">Connect Spectrogram</span>
            </button>

            <!-- Audio Controls -->
            <div
              class="audio-controls-inline"
              id="audioControlsInline"
              style="display: none"
            >
              <button
                id="audioPlayBtn"
                class="btn btn-success"
                onclick="toggleAudioPlayback()"
                disabled
              >
                <span id="audioPlayIcon">üîä</span>
                <span id="audioPlayText">Audio On</span>
              </button>
              <div class="audio-volume-control">
                <label for="audioVolume">Volume:</label>
                <input
                  type="range"
                  id="audioVolume"
                  min="0"
                  max="100"
                  value="60"
                  onchange="updateAudioVolume(this.value)"
                />
                <span id="volumeDisplay">60%</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Live Streams -->
      <div class="stream-container">
        <!-- Spectrogram Card -->
        <div class="dashboard-card spectrogram-card">
          <div class="card-header">
            <h3 class="card-title">Live Spectrogram</h3>
            <span class="card-badge badge-info">Real-time</span>
          </div>
          <div class="card-content">
            <div class="controls-row">
              <div class="control-group">
                <label for="colorScale">Color Scale</label>
                <input
                  type="range"
                  id="colorScale"
                  min="1"
                  max="100"
                  value="50"
                  onchange="updateColorScale(this.value)"
                />
              </div>
              <div class="control-group">
                <label for="maxFreq">Max Freq (Hz)</label>
                <input
                  type="number"
                  id="maxFreq"
                  value="12000"
                  min="1000"
                  max="24000"
                  step="500"
                  onchange="updateFrequencyRange()"
                />
              </div>
              <div class="control-group">
                <label for="timeWindow">Time Window (s)</label>
                <input
                  type="number"
                  id="timeWindow"
                  value="10"
                  min="5"
                  max="60"
                  step="5"
                  onchange="updateTimeWindow(this.value)"
                />
              </div>
            </div>

            <div class="spectrogram-container" style="position: relative">
              <canvas id="spectrogramCanvas"></canvas>
              <div class="frequency-labels">
                <div class="freq-label-top" id="maxFreqLabel">12 kHz</div>
                <div class="freq-label-mid" id="midFreqLabel">6 kHz</div>
                <div class="freq-label-bottom">0 Hz</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Live Detections Card -->
        <div class="dashboard-card detections-card">
          <div class="card-header">
            <h3 class="card-title">Live Detections</h3>
            <span class="card-badge badge-info" id="detectionCount"
              >0 detected</span
            >
          </div>
          <div class="card-content">
            <div id="liveDetections" class="detections-container">
              <p class="no-detections">
                No detections yet. Start streaming to see bird detections in
                real-time.
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- Connection Log Card -->
      <div class="dashboard-card" style="margin-bottom: 2rem">
        <div class="card-header">
          <h3 class="card-title">Connection Log</h3>
        </div>
        <div class="card-content">
          <div id="messages" class="messages-container"></div>
        </div>
      </div>
    </div>

    <script>
      // WebSocket connections
      let audioWs = null;
      let spectrogramWs = null;

      // Canvas and WebGL context for high-performance rendering
      const canvas = document.getElementById("spectrogramCanvas");
      let gl = null;
      let webglProgram = null;
      let webglTexture = null;
      let webglBuffer = null;
      let webglPositionAttribute = null;
      let webglTexCoordAttribute = null;
      let webglTextureUniform = null;

      // Initialize WebGL context and shaders
      function initWebGL() {
        gl =
          canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

        if (!gl) {
          console.error("WebGL not supported, falling back to Canvas 2D");
          // Fallback to 2D context
          const ctx = canvas.getContext("2d");
          return false;
        }

        // Vertex shader for full-screen quad
        const vertexShaderSource = `
          attribute vec2 position;
          attribute vec2 texCoord;
          varying vec2 vTexCoord;
          void main() {
            gl_Position = vec4(position, 0.0, 1.0);
            vTexCoord = texCoord;
          }
        `;

        // Fragment shader with black on white (Merlin/Macaulay Library style)
        const fragmentShaderSource = `
          precision mediump float;
          uniform sampler2D uTexture;
          varying vec2 vTexCoord;
          void main() {
            float intensity = texture2D(uTexture, vTexCoord).r;

            // Black on white: high intensity = black, low intensity = white
            float grayValue = 1.0 - intensity; // High intensity = dark (lower grayValue towards black)
            vec3 color = vec3(grayValue, grayValue, grayValue);

            gl_FragColor = vec4(color, 1.0);
          }
        `;

        // Create and compile shaders
        const vertexShader = createShader(
          gl,
          gl.VERTEX_SHADER,
          vertexShaderSource,
        );
        const fragmentShader = createShader(
          gl,
          gl.FRAGMENT_SHADER,
          fragmentShaderSource,
        );

        if (!vertexShader || !fragmentShader) {
          return false;
        }

        // Create program
        webglProgram = createProgram(gl, vertexShader, fragmentShader);
        if (!webglProgram) {
          return false;
        }

        // Get attribute and uniform locations
        webglPositionAttribute = gl.getAttribLocation(webglProgram, "position");
        webglTexCoordAttribute = gl.getAttribLocation(webglProgram, "texCoord");
        webglTextureUniform = gl.getUniformLocation(webglProgram, "uTexture");

        // Create buffer for full-screen quad
        webglBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, webglBuffer);

        // Full-screen quad vertices with texture coordinates
        const vertices = new Float32Array([
          -1.0,
          -1.0,
          0.0,
          0.0, // Bottom-left
          1.0,
          -1.0,
          1.0,
          0.0, // Bottom-right
          -1.0,
          1.0,
          0.0,
          1.0, // Top-left
          1.0,
          1.0,
          1.0,
          1.0, // Top-right
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        // Create texture for spectrogram data
        webglTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, webglTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        console.log("WebGL initialized successfully");
        return true;
      }

      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(
            "Shader compilation error:",
            gl.getShaderInfoLog(shader),
          );
          gl.deleteShader(shader);
          return null;
        }

        return shader;
      }

      function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error(
            "Program linking error:",
            gl.getProgramInfoLog(program),
          );
          gl.deleteProgram(program);
          return null;
        }

        return program;
      }

      // Set canvas size and initialize WebGL
      function resizeCanvas() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth - 32; // Account for padding
        canvas.height = 400;

        // Initialize WebGL if not already done
        if (!gl) {
          initWebGL();
        }

        // Set WebGL viewport
        if (gl) {
          gl.viewport(0, 0, canvas.width, canvas.height);
        }

        drawSpectrogram(); // Redraw when resized
      }

      // Spectrogram configuration
      let config = {
        sample_rate: 48000,
        window_size: 1024,
        freq_bins: [],
        update_rate: 15.0,
      };

      // Display parameters
      let maxFrequency = 12000;
      let timeWindow = 10; // seconds
      let colorScale = 50;

      // Data storage
      let spectrogramHistory = [];
      let lastUpdateTime = 0;
      let updateCount = 0;
      let startTime = Date.now();

      // UI elements
      const elements = {
        audioStatus: document.getElementById("audioStatus"),
        spectrogramStatus: document.getElementById("spectrogramStatus"),
        updateRate: document.getElementById("updateRate"),
        latency: document.getElementById("latency"),
        audioToggleBtn: document.getElementById("audioToggleBtn"),
        audioToggleIcon: document.getElementById("audioToggleIcon"),
        audioToggleText: document.getElementById("audioToggleText"),
        spectrogramToggleBtn: document.getElementById("spectrogramToggleBtn"),
        spectrogramToggleIcon: document.getElementById("spectrogramToggleIcon"),
        spectrogramToggleText: document.getElementById("spectrogramToggleText"),
        audioControlsInline: document.getElementById("audioControlsInline"),
        messages: document.getElementById("messages"),
        audioPlayBtn: document.getElementById("audioPlayBtn"),
        audioPlayIcon: document.getElementById("audioPlayIcon"),
        audioPlayText: document.getElementById("audioPlayText"),
        audioVolume: document.getElementById("audioVolume"),
        volumeDisplay: document.getElementById("volumeDisplay"),
        liveDetections: document.getElementById("liveDetections"),
        detectionCount: document.getElementById("detectionCount"),
        maxFreqLabel: document.getElementById("maxFreqLabel"),
        midFreqLabel: document.getElementById("midFreqLabel"),
      };

      // Detection tracking
      let detectionsList = [];
      let notificationsWs = null;

      function addMessage(message) {
        const messageDiv = document.createElement("div");
        messageDiv.className = "message";
        messageDiv.textContent =
          new Date().toLocaleTimeString() + ": " + message;
        elements.messages.appendChild(messageDiv);
        elements.messages.scrollTop = elements.messages.scrollHeight;
      }

      function updateStatus(element, connected, text) {
        element.textContent = text;
        element.className = `status-indicator ${
          connected ? "status-connected" : "status-disconnected"
        }`;
      }

      function connect() {
        // Legacy function - now connects both streams independently
        connectAudio();
        connectSpectrogram();
      }

      function toggleAudioConnection() {
        const isConnected = audioWs && audioWs.readyState === WebSocket.OPEN;
        if (isConnected) {
          disconnectAudio();
        } else {
          connectAudio();
        }
      }

      function toggleSpectrogramConnection() {
        const isConnected =
          spectrogramWs && spectrogramWs.readyState === WebSocket.OPEN;
        if (isConnected) {
          disconnectSpectrogram();
        } else {
          connectSpectrogram();
        }
      }

      function connectAudio() {
        if (audioWs && audioWs.readyState === WebSocket.OPEN) {
          addMessage("Audio already connected");
          return;
        }

        elements.audioToggleBtn.disabled = true;
        elements.audioToggleText.textContent = "Connecting...";
        addMessage("Connecting to audio stream...");

        const wsProtocol = location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${wsProtocol}//${location.host}/ws/audio`;

        audioWs = new WebSocket(wsUrl);

        audioWs.onopen = function (event) {
          updateStatus(elements.audioStatus, true, "Audio: Connected");
          addMessage("Audio WebSocket connected");
          elements.audioToggleBtn.disabled = false;
          elements.audioToggleBtn.className = "btn btn-disconnect";
          elements.audioToggleIcon.textContent = "üîá";
          elements.audioToggleText.textContent = "Disconnect Audio";
          elements.audioControlsInline.style.display = "flex";
          elements.audioPlayBtn.disabled = false;
        };

        audioWs.onmessage = function (event) {
          if (event.data instanceof ArrayBuffer) {
            // Handle raw PCM data directly - much faster than MP3!
            handlePCMData(event.data);
          } else if (event.data instanceof Blob) {
            // Convert Blob to ArrayBuffer for PCM processing
            event.data.arrayBuffer().then(handlePCMData);
          } else {
            console.log("Audio non-PCM data:", event.data);
          }
        };

        audioWs.onclose = function (event) {
          updateStatus(elements.audioStatus, false, "Audio: Disconnected");
          addMessage(`Audio WebSocket disconnected: ${event.code}`);
          elements.audioToggleBtn.disabled = false;
          elements.audioToggleBtn.className = "btn btn-primary";
          elements.audioToggleIcon.textContent = "üéµ";
          elements.audioToggleText.textContent = "Connect Audio";
          elements.audioControlsInline.style.display = "none";
          elements.audioPlayBtn.disabled = true;
        };

        audioWs.onerror = function (error) {
          updateStatus(elements.audioStatus, false, "Audio: Error");
          addMessage("Audio WebSocket error");
          elements.audioToggleBtn.disabled = false;
          elements.audioToggleBtn.className = "btn btn-primary";
          elements.audioToggleIcon.textContent = "üéµ";
          elements.audioToggleText.textContent = "Connect Audio";
          elements.audioControlsInline.style.display = "none";
          elements.audioPlayBtn.disabled = true;
        };
      }

      function disconnectAudio() {
        if (audioWs) {
          audioWs.close();
          audioWs = null;
        }

        // Stop current audio context if active
        if (audioContext && audioContext.state !== "closed") {
          // Audio context will stop automatically when connection closes
        }

        elements.audioToggleBtn.disabled = false;
        elements.audioToggleBtn.className = "btn btn-primary";
        elements.audioToggleIcon.textContent = "üéµ";
        elements.audioToggleText.textContent = "Connect Audio";
        elements.audioControlsInline.style.display = "none";
        elements.audioPlayBtn.disabled = true;
        addMessage("Disconnected from audio stream");
      }

      function connectSpectrogram() {
        if (spectrogramWs && spectrogramWs.readyState === WebSocket.OPEN) {
          addMessage("Spectrogram already connected");
          return;
        }

        elements.spectrogramToggleBtn.disabled = true;
        elements.spectrogramToggleText.textContent = "Connecting...";
        addMessage("Connecting to spectrogram stream...");

        // Reset counters when connecting spectrogram
        updateCount = 0;
        startTime = Date.now();
        lastUpdateTime = 0;

        const wsProtocol = location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${wsProtocol}//${location.host}/ws/spectrogram`;

        spectrogramWs = new WebSocket(wsUrl);

        spectrogramWs.onopen = function (event) {
          updateStatus(
            elements.spectrogramStatus,
            true,
            "Spectrogram: Connected",
          );
          addMessage("Spectrogram WebSocket connected");
          elements.spectrogramToggleBtn.disabled = false;
          elements.spectrogramToggleBtn.className = "btn btn-disconnect";
          elements.spectrogramToggleIcon.textContent = "üö´";
          elements.spectrogramToggleText.textContent = "Disconnect Spectrogram";
        };

        spectrogramWs.onmessage = function (event) {
          try {
            const data = JSON.parse(event.data);
            if (data.type === "config") {
              handleSpectrogramConfig(data);
            } else if (data.type === "spectrogram") {
              handleSpectrogramData(data);
            }
          } catch (e) {
            console.log("Spectrogram parse error:", e);
          }
        };

        spectrogramWs.onclose = function (event) {
          updateStatus(
            elements.spectrogramStatus,
            false,
            "Spectrogram: Disconnected",
          );
          addMessage(`Spectrogram WebSocket disconnected: ${event.code}`);
          elements.spectrogramToggleBtn.disabled = false;
          elements.spectrogramToggleBtn.className = "btn btn-primary";
          elements.spectrogramToggleIcon.textContent = "üìä";
          elements.spectrogramToggleText.textContent = "Connect Spectrogram";
        };

        spectrogramWs.onerror = function (error) {
          updateStatus(elements.spectrogramStatus, false, "Spectrogram: Error");
          addMessage("Spectrogram WebSocket error");
          elements.spectrogramToggleBtn.disabled = false;
          elements.spectrogramToggleBtn.className = "btn btn-primary";
          elements.spectrogramToggleIcon.textContent = "üìä";
          elements.spectrogramToggleText.textContent = "Connect Spectrogram";
        };
      }

      function disconnectSpectrogram() {
        if (spectrogramWs) {
          spectrogramWs.close();
          spectrogramWs = null;
        }

        // Clear the canvas and data
        const canvas = document.getElementById("spectrogramCanvas");
        if (canvas) {
          const ctx = canvas.getContext("2d");
          if (ctx) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
          }
        }
        // Also clear WebGL if using WebGL
        if (webglRenderer && webglRenderer.gl) {
          const gl = webglRenderer.gl;
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
        spectrogramHistory = [];

        elements.spectrogramToggleBtn.disabled = false;
        elements.spectrogramToggleBtn.className = "btn btn-primary";
        elements.spectrogramToggleIcon.textContent = "üìä";
        elements.spectrogramToggleText.textContent = "Connect Spectrogram";
        addMessage("Disconnected from spectrogram stream");
      }

      function disconnect() {
        // Legacy function - now disconnects both streams
        disconnectAudio();
        disconnectSpectrogram();
        addMessage("Disconnected from all streams");
      }

      // Audio player management
      let audioEnabled = true;
      let audioVolume = 0.6;
      let currentAudio = null;

      // Web Audio API context for PCM playback
      let audioContext = null;
      let gainNode = null;

      async function initAudioContext() {
        if (!audioContext) {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          gainNode = audioContext.createGain();
          gainNode.connect(audioContext.destination);
          gainNode.gain.value = audioVolume;
        }

        // Resume context if it was suspended (browser autoplay policy)
        if (audioContext.state === "suspended") {
          await audioContext.resume();
        }
      }

      async function handlePCMData(arrayBuffer) {
        if (!audioEnabled) {
          return;
        }

        try {
          await initAudioContext();

          // Parse the packet: 4 bytes length header + PCM data
          const dataView = new DataView(arrayBuffer);
          const dataLength = dataView.getUint32(0, true); // little endian

          if (arrayBuffer.byteLength < 4 + dataLength) {
            console.warn("Invalid PCM packet size");
            return;
          }

          // Extract PCM data (skip 4-byte header)
          const pcmData = new Int16Array(arrayBuffer, 4, dataLength / 2);

          // Convert int16 PCM to float32 for Web Audio API
          const sampleRate = 48000; // Match server sample rate
          const channels = 1;
          const audioBuffer = audioContext.createBuffer(
            channels,
            pcmData.length,
            sampleRate,
          );
          const channelData = audioBuffer.getChannelData(0);

          // Convert int16 to float32 (-1.0 to 1.0)
          for (let i = 0; i < pcmData.length; i++) {
            channelData[i] = pcmData[i] / 32768.0;
          }

          // Play the audio buffer immediately
          const source = audioContext.createBufferSource();
          source.buffer = audioBuffer;
          source.connect(gainNode);
          source.start(0);
        } catch (error) {
          console.error("PCM audio playback error:", error);
        }
      }

      function handleAudioData(audioBlob) {
        // Legacy function - kept for compatibility but no longer used
        console.warn(
          "handleAudioData called - should use handlePCMData for better performance",
        );
      }

      function toggleAudioPlayback() {
        audioEnabled = !audioEnabled;

        if (audioEnabled) {
          elements.audioPlayIcon.textContent = "üîä";
          elements.audioPlayText.textContent = "Audio On";
          elements.audioPlayBtn.className = "btn btn-success";
          addMessage("Audio playback enabled");
        } else {
          elements.audioPlayIcon.textContent = "üîá";
          elements.audioPlayText.textContent = "Audio Off";
          elements.audioPlayBtn.className = "btn btn-secondary";
          addMessage("Audio playback disabled");
        }
      }

      function updateAudioVolume(value) {
        audioVolume = value / 100;

        // Update Web Audio API gain node if available
        if (gainNode) {
          gainNode.gain.value = audioVolume;
        }
        elements.volumeDisplay.textContent = value + "%";
      }

      // Setup audio controls
      function setupAudioPlayerControls() {
        // Enable audio play button when audio is connected
        // (this will be called from connectAudio function)
      }

      // Detection management
      function addDetection(detection) {
        const timestamp = new Date().toLocaleTimeString();

        const detectionItem = {
          species:
            detection.species || detection.common_name || "Unknown Species",
          confidence: detection.confidence || 0,
          timestamp: timestamp,
          id: Date.now() + Math.random(),
        };

        detectionsList.unshift(detectionItem); // Add to beginning

        // Limit to 50 detections
        if (detectionsList.length > 50) {
          detectionsList = detectionsList.slice(0, 50);
        }

        updateDetectionDisplay();
        updateDetectionCount();
      }

      function updateDetectionDisplay() {
        const container = elements.liveDetections;

        if (detectionsList.length === 0) {
          container.innerHTML =
            '<p class="no-detections">No detections yet. Start streaming to see bird detections in real-time.</p>';
          return;
        }

        const html = detectionsList
          .map(
            (detection) => `
          <div class="detection-item">
            <div class="detection-info">
              <div class="detection-species">${detection.species}</div>
              <div class="detection-confidence">${(detection.confidence * 100).toFixed(1)}% confidence</div>
            </div>
            <div class="detection-time">${detection.timestamp}</div>
          </div>
        `,
          )
          .join("");

        container.innerHTML = html;
      }

      function updateDetectionCount() {
        const count = detectionsList.length;
        elements.detectionCount.textContent = `${count} detected`;
      }

      // Connect to notifications WebSocket for detections
      function connectNotifications() {
        const wsProtocol = location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${wsProtocol}//${location.host}/ws/notifications`;

        notificationsWs = new WebSocket(wsUrl);

        notificationsWs.onopen = function (event) {
          // addMessage("Notifications WebSocket connected");
        };

        notificationsWs.onmessage = function (event) {
          try {
            const data = JSON.parse(event.data);

            // Handle detection notifications
            if (data.type === "detection" && data.detection) {
              addDetection(data.detection);
              addMessage(
                `Detected: ${data.detection.species || data.detection.common_name}`,
              );
            }
          } catch (e) {
            console.log("Notifications message:", event.data);
          }
        };

        notificationsWs.onclose = function (event) {
          // addMessage("Notifications WebSocket disconnected");
          // Auto-reconnect after a delay
          setTimeout(connectNotifications, 5000);
        };

        notificationsWs.onerror = function (error) {
          addMessage("Notifications WebSocket error");
        };
      }

      function handleSpectrogramConfig(configData) {
        config = configData;
        // addMessage(`Spectrogram config: ${config.sample_rate}Hz, window=${config.window_size}`);
        updateFrequencyLabels();
      }

      function handleSpectrogramData(data) {
        const now = Date.now();

        // Calculate update rate and latency
        updateCount++;
        const elapsedTime = (now - startTime) / 1000;
        if (elapsedTime > 0) {
          const currentUpdateRate = updateCount / elapsedTime;
          elements.updateRate.textContent = `Updates: ${currentUpdateRate.toFixed(1)} Hz`;
        }

        if (lastUpdateTime > 0 && data.timestamp) {
          const latency = now - data.timestamp * 1000;
          elements.latency.textContent = `Latency: ${Math.round(Math.abs(latency))} ms`;
        }
        lastUpdateTime = now;

        // IMPORTANT: Limit history size BEFORE adding new data to prevent accumulation
        const targetSlices = Math.ceil(timeWindow * config.update_rate); // Target ~150 slices for 10s at 15Hz

        // Aggressively prune old data first
        if (spectrogramHistory.length > targetSlices * 0.7) {
          spectrogramHistory = spectrogramHistory.slice(
            -Math.floor(targetSlices * 0.7),
          );
        }

        // Handle 2D spectrogram data: data.data is [freq_bins][time_slices]
        // Convert to format expected by drawing code: array of time slices
        if (data.data && data.shape && data.shape.length === 2) {
          const [timeSlices, freqBins] = data.shape; // After Python .T transpose: (time, frequency)
          const spectrogramMatrix = data.data;

          // Debug data format (limit to once per 100 messages to avoid spam)
          if (Math.random() < 0.01) {
            console.log("Spectrogram data format:", {
              shape: data.shape,
              dataType: Array.isArray(spectrogramMatrix)
                ? "array"
                : typeof spectrogramMatrix,
              dataLength: spectrogramMatrix?.length,
              firstElementType: Array.isArray(spectrogramMatrix?.[0])
                ? "array"
                : typeof spectrogramMatrix?.[0],
              firstElementLength: spectrogramMatrix?.[0]?.length,
              timeSlices: timeSlices,
              freqBins: freqBins,
            });
          }

          // Safety check: ensure spectrogramMatrix is an array
          if (
            !Array.isArray(spectrogramMatrix) ||
            spectrogramMatrix.length === 0
          ) {
            console.log("Invalid spectrogram matrix format");
            return;
          }

          // Limit the number of new slices we add per message to prevent flooding
          const maxNewSlices = Math.min(
            timeSlices,
            spectrogramMatrix.length,
            10,
          );

          // Convert from [timeSlices][freqBins] to array of timeSlice arrays
          for (let timeIndex = 0; timeIndex < maxNewSlices; timeIndex++) {
            const timeSlice = spectrogramMatrix[timeIndex];
            if (!Array.isArray(timeSlice)) {
              // This might happen if the data structure is different than expected
              if (Math.random() < 0.1) {
                // Log occasionally
                console.log(
                  `Time slice ${timeIndex} is not an array:`,
                  typeof timeSlice,
                );
              }
              continue;
            }

            if (timeSlice.length !== freqBins) {
              // This might happen if frequency bins don't match expected count
              if (Math.random() < 0.1) {
                // Log occasionally
                console.log(
                  `Time slice ${timeIndex} length mismatch:`,
                  timeSlice.length,
                  "vs expected",
                  freqBins,
                );
              }
              continue;
            }

            // Copy the frequency data for this time slice
            const timeSliceData = [...timeSlice]; // Shallow copy is sufficient for numbers

            spectrogramHistory.push({
              data: timeSliceData,
              timestamp:
                now -
                (maxNewSlices - timeIndex - 1) * (1000 / config.update_rate),
            });
          }
        }

        // Final safety check - hard limit to prevent any accumulation
        if (spectrogramHistory.length > targetSlices) {
          spectrogramHistory = spectrogramHistory.slice(-targetSlices);
        }

        // Draw the spectrogram
        drawSpectrogram();
      }

      function drawSpectrogram() {
        if (spectrogramHistory.length === 0) return;

        // Try WebGL first, fallback to Canvas if WebGL unavailable
        if (gl && webglProgram) {
          drawSpectrogramWebGL();
        } else {
          drawSpectrogramCanvas();
        }
      }

      function drawSpectrogramWebGL() {
        const timeSlices = spectrogramHistory.length;
        if (timeSlices === 0) return;

        // Get the frequency range to display
        const maxFreqIndex =
          config.freq_bins.length > 0
            ? Math.floor(
                (maxFrequency / (config.sample_rate / 2)) *
                  config.freq_bins.length,
              )
            : spectrogramHistory[0].data.length;

        const freqBins = Math.min(
          spectrogramHistory[0].data.length,
          maxFreqIndex,
        );

        // Create texture data (RGBA format)
        const textureWidth = timeSlices;
        const textureHeight = freqBins;
        const textureData = new Uint8Array(textureWidth * textureHeight * 4);

        // Fill texture data from spectrogram history
        spectrogramHistory.forEach((item, timeIndex) => {
          const spectrogramData = item.data;
          if (!spectrogramData || !Array.isArray(spectrogramData)) return;

          for (let freqIndex = 0; freqIndex < freqBins; freqIndex++) {
            const magnitude = spectrogramData[freqIndex];

            // Convert magnitude to normalized intensity (0-1)
            const normalizedMagnitude = Math.max(
              0,
              Math.min(
                1,
                ((magnitude + 60) / 60) * (colorScale / 50), // Assuming -60dB to 0dB range
              ),
            );

            // Calculate texture index (freqIndex 0 = low freq should be at bottom of texture)
            const texelIndex = (freqIndex * textureWidth + timeIndex) * 4;

            // Store normalized intensity in red channel (fragment shader will colorize)
            textureData[texelIndex] = Math.floor(normalizedMagnitude * 255); // R
            textureData[texelIndex + 1] = 0; // G (unused)
            textureData[texelIndex + 2] = 0; // B (unused)
            textureData[texelIndex + 3] = 255; // A (opaque)
          }
        });

        // Upload texture data to GPU
        gl.bindTexture(gl.TEXTURE_2D, webglTexture);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          textureWidth,
          textureHeight,
          0,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          textureData,
        );

        // Clear and render with white background
        gl.clearColor(1.0, 1.0, 1.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(webglProgram);

        // Bind vertex buffer and set attributes
        gl.bindBuffer(gl.ARRAY_BUFFER, webglBuffer);

        gl.enableVertexAttribArray(webglPositionAttribute);
        gl.vertexAttribPointer(
          webglPositionAttribute,
          2,
          gl.FLOAT,
          false,
          16,
          0,
        );

        gl.enableVertexAttribArray(webglTexCoordAttribute);
        gl.vertexAttribPointer(
          webglTexCoordAttribute,
          2,
          gl.FLOAT,
          false,
          16,
          8,
        );

        // Bind texture and set uniform
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, webglTexture);
        gl.uniform1i(webglTextureUniform, 0);

        // Render full-screen quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }

      function drawSpectrogramCanvas() {
        // Fallback Canvas 2D implementation
        const ctx = canvas.getContext("2d");
        if (!ctx) return;

        // Disable image smoothing for pixel-perfect rendering
        ctx.imageSmoothingEnabled = false;

        const width = canvas.width;
        const height = canvas.height;

        // Clear canvas with white background (Merlin/Macaulay Library style)
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, width, height);

        // Calculate dimensions
        const timeSlices = spectrogramHistory.length;
        if (timeSlices === 0) return;

        const sliceWidth = width / timeSlices;

        // Get the frequency range to display
        const maxFreqIndex =
          config.freq_bins.length > 0
            ? Math.floor(
                (maxFrequency / (config.sample_rate / 2)) *
                  config.freq_bins.length,
              )
            : spectrogramHistory[0].data.length;

        spectrogramHistory.forEach((item, timeIndex) => {
          const spectrogramData = item.data;
          if (!spectrogramData || !Array.isArray(spectrogramData)) return;

          const freqBins = Math.min(spectrogramData.length, maxFreqIndex);

          for (let freqIndex = 0; freqIndex < freqBins; freqIndex++) {
            const magnitude = spectrogramData[freqIndex];

            // Convert magnitude to color intensity
            const normalizedMagnitude = Math.max(
              0,
              Math.min(
                1,
                ((magnitude + 60) / 60) * (colorScale / 50), // Assuming -60dB to 0dB range
              ),
            );

            // Black on white grayscale (Merlin/Macaulay Library style)
            // High magnitude = dark/black, low magnitude = light/white
            const grayValue = Math.floor(255 * (1 - normalizedMagnitude));

            ctx.fillStyle = `rgb(${grayValue},${grayValue},${grayValue})`;

            // Draw rectangle (low frequencies at bottom, high frequencies at top)
            const x = timeIndex * sliceWidth;
            const y = (freqIndex / freqBins) * height; // freqIndex 0 (low freq) at y=0 (bottom)
            const rectHeight = Math.max(1, height / freqBins);

            ctx.fillRect(x, y, Math.ceil(sliceWidth), Math.ceil(rectHeight));
          }
        });
      }

      function updateColorScale(value) {
        colorScale = parseInt(value);
        drawSpectrogram();
      }

      function updateFrequencyRange() {
        const newMaxFreq = parseInt(document.getElementById("maxFreq").value);
        maxFrequency = Math.min(newMaxFreq, config.sample_rate / 2);
        updateFrequencyLabels();
        drawSpectrogram();
      }

      function updateTimeWindow(value) {
        timeWindow = parseInt(value);
        // Clear old data that's outside the new window
        const now = Date.now();
        const cutoffTime = now - timeWindow * 1000;
        spectrogramHistory = spectrogramHistory.filter(
          (item) => item.timestamp > cutoffTime,
        );
        drawSpectrogram();
      }

      function updateFrequencyLabels() {
        elements.maxFreqLabel.textContent = `${(maxFrequency / 1000).toFixed(1)} kHz`;
        elements.midFreqLabel.textContent = `${(maxFrequency / 2000).toFixed(1)} kHz`;
      }

      // Initialize
      window.addEventListener("load", function () {
        resizeCanvas();
        updateFrequencyLabels();
        setupAudioPlayerControls();
        connectNotifications();
        // addMessage("Page loaded. Use individual Connect buttons to start audio and/or spectrogram streaming.");
      });

      // Handle window resize
      window.addEventListener("resize", resizeCanvas);

      // Handle page visibility changes
      document.addEventListener("visibilitychange", function () {
        if (document.hidden) {
          // addMessage("Page hidden - maintaining connections");
        } else if (!document.hidden) {
          // addMessage("Page visible - connections active");
          // Redraw in case canvas was cleared
          if (spectrogramHistory.length > 0) {
            drawSpectrogram();
          }
        }
      });

      // Keep connections alive
      setInterval(() => {
        if (audioWs && audioWs.readyState === WebSocket.OPEN) {
          audioWs.send("ping");
        }
        if (spectrogramWs && spectrogramWs.readyState === WebSocket.OPEN) {
          spectrogramWs.send("ping");
        }
      }, 30000);
    </script>
  </body>
</html>
