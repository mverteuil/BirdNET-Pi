/**
 * Analysis JavaScript - Data visualization and chart rendering
 */

// Initialize analysis data via AJAX
async function initAnalysisPage() {
  console.log("[Analysis] Initializing analysis page...");

  // Check if we're on the analysis page
  if (!window.analysisConfig) {
    console.log("[Analysis] Not on analysis page");
    return;
  }

  try {
    // Fetch analysis data from API
    const params = new URLSearchParams({
      period: window.analysisConfig.period,
      comparison: window.analysisConfig.comparisonPeriod
    });

    console.log("[Analysis] Fetching data from API...");
    const response = await fetch(`/api/analysis/all?${params}`);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();

    // Store the analyses data globally
    window.analysisData = data.analyses || {};
    if (data.dates) {
      window.analysisData.dates = data.dates;
    }

    console.log(
      "[Analysis] Data loaded via AJAX, keys:",
      Object.keys(window.analysisData),
    );

    // Initialize all visualizations
    initializeAnalysis();
  } catch (error) {
    console.error("[Analysis] Error fetching data:", error);
    showErrorState(error.message);
  }
}

function showErrorState(message) {
  const sections = document.querySelectorAll('.analysis-section');
  sections.forEach(section => {
    const error = document.createElement('div');
    error.className = 'error-message';
    error.style.color = 'red';
    error.textContent = `Error loading data: ${message}`;
    section.appendChild(error);
  });
}

// Handle both DOMContentLoaded and immediate execution
if (document.readyState === "loading") {
  // DOM is still loading, wait for it
  document.addEventListener("DOMContentLoaded", initAnalysisPage);
} else {
  // DOM is already ready (script loaded after DOMContentLoaded fired)
  initAnalysisPage();
}

// Initialize all analysis visualizations
function initializeAnalysis() {
  console.log("[Analysis] Starting chart initialization...");
  let chartsDrawn = 0;

  // Draw only charts that have canvas elements in the DOM
  if (document.getElementById("diversity-timeline")) {
    console.log("[Analysis] Drawing diversity timeline...");
    drawDiversityTimeline();
    chartsDrawn++;
  }
  if (document.getElementById("activity-heatmap")) {
    console.log("[Analysis] Drawing activity heatmap...");
    drawActivityHeatmap();
    chartsDrawn++;
  }
  // Note: temporal-chart, confidence-chart, species-chart not in current template
  if (document.getElementById("accumulation-curve")) {
    console.log("[Analysis] Drawing accumulation curve...");
    drawAccumulationCurve();
    chartsDrawn++;
  }
  if (document.getElementById("beta-diversity")) {
    console.log("[Analysis] Drawing beta diversity...");
    drawBetaDiversity();
    chartsDrawn++;
  }
  if (
    document.getElementById("temp-correlation") ||
    document.getElementById("humidity-correlation") ||
    document.getElementById("wind-correlation")
  ) {
    console.log("[Analysis] Drawing weather correlations...");
    drawWeatherCorrelations();
    chartsDrawn++;
  }

  // Populate similarity matrix if we have the data
  if (document.getElementById("similarity-matrix-container")) {
    console.log("[Analysis] Populating similarity matrix...");
    populateSimilarityMatrix();
    chartsDrawn++;
  }

  console.log(
    `[Analysis] Initialization complete. ${chartsDrawn} charts drawn.`,
  );

  // Set up tab functionality
  setupTabNavigation();
}

// Draw diversity timeline using canvas
function drawDiversityTimeline() {
  const canvas = document.getElementById("diversity-timeline");
  if (!canvas || !window.analysisData || !window.analysisData.diversity) return;

  const ctx = canvas.getContext("2d");
  const data = window.analysisData.diversity;

  // Canvas dimensions
  const padding = { left: 50, right: 30, top: 20, bottom: 40 };
  const width = canvas.width - padding.left - padding.right;
  const height = canvas.height - padding.top - padding.bottom;

  // Clear canvas
  ctx.fillStyle = "#fdfcfa";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw axes
  ctx.strokeStyle = "#111";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding.left, padding.top);
  ctx.lineTo(padding.left, padding.top + height);
  ctx.lineTo(padding.left + width, padding.top + height);
  ctx.stroke();

  // Scale data
  const maxShannon = Math.max(...data.shannon);
  const maxRichness = Math.max(...data.richness);

  // Determine if we need to sample the data for cleaner lines
  const maxLinePoints = 100; // Maximum points for smooth line drawing
  let lineData = data;

  if (data.periods.length > maxLinePoints) {
    // Sample the data to reduce points
    const sampleRate = Math.ceil(data.periods.length / maxLinePoints);
    lineData = {
      periods: [],
      shannon: [],
      simpson: [],
      richness: [],
    };

    for (let i = 0; i < data.periods.length; i += sampleRate) {
      lineData.periods.push(data.periods[i]);
      lineData.shannon.push(data.shannon[i]);
      lineData.simpson.push(data.simpson[i]);
      lineData.richness.push(data.richness[i]);
    }
  }

  // Draw Shannon diversity line
  ctx.strokeStyle = "#0066cc";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  lineData.shannon.forEach((value, i) => {
    const x = padding.left + (i / (lineData.shannon.length - 1)) * width;
    const y = padding.top + height - (value / maxShannon) * height;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
  ctx.stroke();

  // Draw Simpson diversity line
  ctx.strokeStyle = "#ff9900";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  lineData.simpson.forEach((value, i) => {
    const x = padding.left + (i / (lineData.simpson.length - 1)) * width;
    const y = padding.top + height - value * height; // Simpson is 0-1
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
  ctx.stroke();

  // Draw species richness line (secondary axis)
  ctx.strokeStyle = "#00aa00";
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  lineData.richness.forEach((value, i) => {
    const x = padding.left + (i / (lineData.richness.length - 1)) * width;
    const y = padding.top + height - (value / maxRichness) * height;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
  ctx.stroke();

  // Draw Y-axis labels
  ctx.fillStyle = "#444";
  ctx.font = "10px Inter";
  ctx.textAlign = "right";

  // Shannon labels
  for (let i = 0; i <= 4; i++) {
    const value = (maxShannon * i) / 4;
    const y = padding.top + height - (i / 4) * height;
    ctx.fillText(value.toFixed(1), padding.left - 5, y + 3);
  }

  // Draw X-axis labels (sample to avoid overcrowding)
  ctx.textAlign = "center";
  const labelInterval = Math.max(1, Math.floor(data.periods.length / 10));
  for (let i = 0; i < data.periods.length; i += labelInterval) {
    const x = padding.left + (i / (data.periods.length - 1)) * width;
    const label = data.periods[i];
    ctx.fillText(label, x, canvas.height - 20);
  }

  // Draw legend
  const legendY = 10;
  const legendItems = [
    { color: "#0066cc", label: "Shannon" },
    { color: "#ff9900", label: "Simpson" },
    { color: "#00aa00", label: "Richness" },
  ];

  legendItems.forEach((item, i) => {
    const x = padding.left + 100 + i * 80;
    ctx.fillStyle = item.color;
    ctx.fillRect(x, legendY, 15, 10);
    ctx.fillStyle = "#444";
    ctx.font = "11px Inter";
    ctx.textAlign = "left";
    ctx.fillText(item.label, x + 20, legendY + 8);
  });
}

// Draw activity heatmap
function drawActivityHeatmap() {
  const canvas = document.getElementById("activity-heatmap");
  if (!canvas || !window.analysisData || !window.analysisData.temporal_patterns || !window.analysisData.temporal_patterns.heatmap)
    return;

  const ctx = canvas.getContext("2d");
  const data = window.analysisData.temporal_patterns.heatmap;

  // Canvas dimensions
  const cellSize = 25;
  const padding = { left: 50, right: 20, top: 40, bottom: 30 };
  const gridWidth = 24 * cellSize;
  const gridHeight = 7 * cellSize;

  canvas.width = gridWidth + padding.left + padding.right;
  canvas.height = gridHeight + padding.top + padding.bottom;

  // Clear canvas
  ctx.fillStyle = "#fdfcfa";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Find max value for scaling
  const maxValue = Math.max(...data.flat());

  // Draw heatmap cells
  data.forEach((dayData, dayIndex) => {
    dayData.forEach((value, hourIndex) => {
      const x = padding.left + hourIndex * cellSize;
      const y = padding.top + dayIndex * cellSize;

      // Calculate color intensity
      const intensity = maxValue > 0 ? value / maxValue : 0;
      const alpha = 0.1 + intensity * 0.8;

      // Use a gradient from light to dark blue
      ctx.fillStyle = `rgba(0, 102, 204, ${alpha})`;
      ctx.fillRect(x, y, cellSize - 1, cellSize - 1);

      // Add text for significant values
      if (value > 0) {
        ctx.fillStyle = intensity > 0.5 ? "#fff" : "#444";
        ctx.font = "10px Inter";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(value.toString(), x + cellSize / 2, y + cellSize / 2);
      }
    });
  });

  // Draw hour labels
  ctx.fillStyle = "#666";
  ctx.font = "10px Inter";
  ctx.textAlign = "center";
  for (let hour = 0; hour < 24; hour++) {
    const x = padding.left + hour * cellSize + cellSize / 2;
    ctx.fillText(hour.toString().padStart(2, "0"), x, padding.top - 5);
  }

  // Draw day labels
  const days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  ctx.textAlign = "right";
  days.forEach((day, i) => {
    const y = padding.top + i * cellSize + cellSize / 2;
    ctx.fillText(day, padding.left - 5, y);
  });

  // Draw title
  ctx.fillStyle = "#222";
  ctx.font = "12px Inter";
  ctx.textAlign = "center";
  ctx.fillText("Activity by Hour and Day", canvas.width / 2, 20);
}

// Draw temporal patterns chart
function drawTemporalChart() {
  const canvas = document.getElementById("temporal-chart");
  if (!canvas || !window.analysisData || !window.analysisData.temporal_patterns) return;

  const ctx = canvas.getContext("2d");
  const data = window.analysisData.temporal_patterns;

  // Canvas dimensions
  const padding = { left: 50, right: 30, top: 20, bottom: 40 };
  const width = canvas.width - padding.left - padding.right;
  const height = canvas.height - padding.top - padding.bottom;

  // Clear canvas
  ctx.fillStyle = "#fdfcfa";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw axes
  ctx.strokeStyle = "#ddd";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding.left, padding.top);
  ctx.lineTo(padding.left, padding.top + height);
  ctx.lineTo(padding.left + width, padding.top + height);
  ctx.stroke();

  // Prepare data
  const hourlyData = data.hourly || [];
  const maxCount = Math.max(...hourlyData.map((d) => d.count));

  // Draw bars
  const barWidth = width / 24;
  hourlyData.forEach((item, i) => {
    const barHeight = (item.count / maxCount) * height;
    const x = padding.left + i * barWidth;
    const y = padding.top + height - barHeight;

    // Bar
    ctx.fillStyle = "#0066cc";
    ctx.fillRect(x + barWidth * 0.1, y, barWidth * 0.8, barHeight);

    // Species count on hover (we'll show as text for now)
    if (item.species_count > 0) {
      ctx.fillStyle = "#666";
      ctx.font = "9px Inter";
      ctx.textAlign = "center";
      ctx.fillText(item.species_count, x + barWidth / 2, y - 5);
    }
  });

  // X-axis labels
  ctx.fillStyle = "#666";
  ctx.font = "10px Inter";
  ctx.textAlign = "center";
  for (let hour = 0; hour < 24; hour += 3) {
    const x = padding.left + hour * barWidth + barWidth / 2;
    ctx.fillText(hour.toString().padStart(2, "0"), x, canvas.height - 20);
  }

  // Y-axis labels
  ctx.textAlign = "right";
  for (let i = 0; i <= 5; i++) {
    const value = Math.round((maxCount * i) / 5);
    const y = padding.top + height - (i / 5) * height;
    ctx.fillText(value.toString(), padding.left - 5, y + 3);
  }

  // Title
  ctx.fillStyle = "#222";
  ctx.font = "12px Inter";
  ctx.textAlign = "center";
  ctx.fillText("Detections by Hour", canvas.width / 2, 15);
}

// Draw confidence distribution chart
function drawConfidenceChart() {
  const canvas = document.getElementById("confidence-chart");
  if (!canvas || !window.analysisData || !window.analysisData.confidence)
    return;

  const ctx = canvas.getContext("2d");
  const data = window.analysisData.confidence;

  // Canvas dimensions
  const padding = { left: 50, right: 30, top: 20, bottom: 40 };
  const width = canvas.width - padding.left - padding.right;
  const height = canvas.height - padding.top - padding.bottom;

  // Clear canvas
  ctx.fillStyle = "#fdfcfa";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw axes
  ctx.strokeStyle = "#ddd";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding.left, padding.top);
  ctx.lineTo(padding.left, padding.top + height);
  ctx.lineTo(padding.left + width, padding.top + height);
  ctx.stroke();

  // Prepare histogram data
  const bins = data.bins || [];
  const maxCount = Math.max(...bins.map((b) => b.count));

  // Draw histogram bars
  const barWidth = width / bins.length;
  bins.forEach((bin, i) => {
    const barHeight = (bin.count / maxCount) * height;
    const x = padding.left + i * barWidth;
    const y = padding.top + height - barHeight;

    // Gradient color based on confidence level
    const confidence = (bin.min + bin.max) / 2;
    const hue = 120 * confidence; // From red (0) to green (120)
    ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
    ctx.fillRect(x + barWidth * 0.05, y, barWidth * 0.9, barHeight);
  });

  // X-axis labels
  ctx.fillStyle = "#666";
  ctx.font = "10px Inter";
  ctx.textAlign = "center";
  bins.forEach((bin, i) => {
    if (i % 2 === 0) {
      // Show every other label to avoid crowding
      const x = padding.left + i * barWidth + barWidth / 2;
      const label = `${Math.round(bin.min * 100)}%`;
      ctx.fillText(label, x, canvas.height - 20);
    }
  });

  // Y-axis labels
  ctx.textAlign = "right";
  for (let i = 0; i <= 5; i++) {
    const value = Math.round((maxCount * i) / 5);
    const y = padding.top + height - (i / 5) * height;
    ctx.fillText(value.toString(), padding.left - 5, y + 3);
  }

  // Statistics
  if (data.mean) {
    ctx.fillStyle = "#222";
    ctx.font = "11px Inter";
    ctx.textAlign = "left";
    const statsY = padding.top + 20;
    ctx.fillText(
      `Mean: ${(data.mean * 100).toFixed(1)}%`,
      padding.left + 10,
      statsY,
    );
    ctx.fillText(
      `Median: ${(data.median * 100).toFixed(1)}%`,
      padding.left + 100,
      statsY,
    );
    ctx.fillText(
      `Std Dev: ${(data.std_dev * 100).toFixed(1)}%`,
      padding.left + 200,
      statsY,
    );
  }

  // Title
  ctx.fillStyle = "#222";
  ctx.font = "12px Inter";
  ctx.textAlign = "center";
  ctx.fillText("Confidence Distribution", canvas.width / 2, 15);
}

// Draw species frequency chart
function drawSpeciesChart() {
  const canvas = document.getElementById("species-chart");
  if (!canvas || !window.analysisData || !window.analysisData.species_frequency)
    return;

  const ctx = canvas.getContext("2d");
  const data = window.analysisData.species_frequency.slice(0, 20); // Top 20 species

  // Canvas dimensions
  const padding = { left: 150, right: 30, top: 20, bottom: 30 };
  const width = canvas.width - padding.left - padding.right;
  const height = canvas.height - padding.top - padding.bottom;

  // Clear canvas
  ctx.fillStyle = "#fdfcfa";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Calculate bar dimensions
  const barHeight = height / data.length;
  const maxCount = Math.max(...data.map((s) => s.count));

  // Draw bars
  data.forEach((species, i) => {
    const barWidth = (species.count / maxCount) * width;
    const x = padding.left;
    const y = padding.top + i * barHeight;

    // Bar
    ctx.fillStyle = "#0066cc";
    ctx.fillRect(x, y + barHeight * 0.1, barWidth, barHeight * 0.8);

    // Species name
    ctx.fillStyle = "#222";
    ctx.font = "11px Inter";
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    const name = species.common_name || species.scientific_name;
    const truncatedName =
      name.length > 20 ? name.substring(0, 20) + "..." : name;
    ctx.fillText(truncatedName, padding.left - 5, y + barHeight / 2);

    // Count
    ctx.textAlign = "left";
    ctx.fillText(species.count.toString(), x + barWidth + 5, y + barHeight / 2);
  });

  // Title
  ctx.fillStyle = "#222";
  ctx.font = "12px Inter";
  ctx.textAlign = "center";
  ctx.fillText("Top Species by Detection Count", canvas.width / 2, 15);
}

// Tab navigation setup
function setupTabNavigation() {
  const tabButtons = document.querySelectorAll(".tab-button");
  const tabPanels = document.querySelectorAll(".tab-panel");

  tabButtons.forEach((button) => {
    button.addEventListener("click", () => {
      const targetTab = button.dataset.tab;

      // Update button states
      tabButtons.forEach((btn) => btn.classList.remove("active"));
      button.classList.add("active");

      // Update panel visibility
      tabPanels.forEach((panel) => {
        if (panel.id === targetTab) {
          panel.classList.add("active");
          panel.style.display = "block";
        } else {
          panel.classList.remove("active");
          panel.style.display = "none";
        }
      });

      // Redraw charts when tab becomes visible
      if (targetTab === "diversity-tab") {
        drawDiversityTimeline();
      } else if (targetTab === "temporal-tab") {
        drawTemporalChart();
        drawActivityHeatmap();
      } else if (targetTab === "confidence-tab") {
        drawConfidenceChart();
      } else if (targetTab === "species-tab") {
        drawSpeciesChart();
      }
    });
  });
}

// Draw species accumulation curve
function drawAccumulationCurve() {
  const canvas = document.getElementById("accumulation-curve");
  if (!canvas || !window.analysisData || !window.analysisData.accumulation)
    return;

  const ctx = canvas.getContext("2d");
  const data = window.analysisData.accumulation;

  // Canvas dimensions
  const padding = { left: 50, right: 30, top: 20, bottom: 40 };
  const width = canvas.width - padding.left - padding.right;
  const height = canvas.height - padding.top - padding.bottom;

  // Clear canvas
  ctx.fillStyle = "#fdfcfa";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw axes
  ctx.strokeStyle = "#ddd";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding.left, padding.top);
  ctx.lineTo(padding.left, padding.top + height);
  ctx.lineTo(padding.left + width, padding.top + height);
  ctx.stroke();

  // Draw accumulation curve
  if (data.curve && data.curve.length > 0) {
    const maxSamples =
      data.total_samples || Math.max(...data.curve.map((p) => p.samples));
    const maxSpecies =
      data.total_species || Math.max(...data.curve.map((p) => p.species));

    ctx.strokeStyle = "#0066cc";
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.curve.forEach((point, i) => {
      const x = padding.left + (point.samples / maxSamples) * width;
      const y = padding.top + height - (point.species / maxSpecies) * height;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
  }

  // Title
  ctx.fillStyle = "#222";
  ctx.font = "12px Inter";
  ctx.textAlign = "center";
  ctx.fillText("Species Accumulation Curve", canvas.width / 2, 15);
}

// Draw beta diversity timeline
function drawBetaDiversity() {
  const canvas = document.getElementById("beta-diversity");
  if (!canvas || !window.analysisData || !window.analysisData.beta_diversity)
    return;

  const ctx = canvas.getContext("2d");
  const data = window.analysisData.beta_diversity;

  // Canvas dimensions
  const padding = { left: 50, right: 30, top: 20, bottom: 40 };
  const width = canvas.width - padding.left - padding.right;
  const height = canvas.height - padding.top - padding.bottom;

  // Clear canvas
  ctx.fillStyle = "#fdfcfa";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw axes
  ctx.strokeStyle = "#ddd";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(padding.left, padding.top);
  ctx.lineTo(padding.left, padding.top + height);
  ctx.lineTo(padding.left + width, padding.top + height);
  ctx.stroke();

  // Draw beta diversity line
  if (data.values && data.values.length > 0) {
    ctx.strokeStyle = "#ff6600";
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.values.forEach((value, i) => {
      const x = padding.left + (i / (data.values.length - 1)) * width;
      const y = padding.top + height - value * height;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    });
    ctx.stroke();
  }

  // Title
  ctx.fillStyle = "#222";
  ctx.font = "12px Inter";
  ctx.textAlign = "center";
  ctx.fillText("Beta Diversity Over Time", canvas.width / 2, 15);
}

// Draw weather correlation scatter plots
function drawWeatherCorrelations() {
  if (
    !window.analysisData ||
    !window.analysisData.weather ||
    !window.analysisData.weather.scatter_data
  )
    return;

  const correlations = [
    { canvas: "temp-correlation", data: "temperature", color: "#ff6600" },
    { canvas: "humidity-correlation", data: "humidity", color: "#0066cc" },
    { canvas: "wind-correlation", data: "wind_speed", color: "#00aa00" },
  ];

  correlations.forEach((corr) => {
    const canvas = document.getElementById(corr.canvas);
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    const scatterData = window.analysisData.weather.scatter_data[corr.data];

    if (!scatterData) return;

    // Canvas dimensions
    const padding = { left: 40, right: 20, top: 20, bottom: 40 };
    const width = canvas.width - padding.left - padding.right;
    const height = canvas.height - padding.top - padding.bottom;

    // Clear canvas
    ctx.fillStyle = "#fdfcfa";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw axes
    ctx.strokeStyle = "#ddd";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding.left, padding.top);
    ctx.lineTo(padding.left, padding.top + height);
    ctx.lineTo(padding.left + width, padding.top + height);
    ctx.stroke();

    // Draw scatter points
    if (scatterData.points && scatterData.points.length > 0) {
      const maxX = Math.max(...scatterData.points.map((p) => p.x));
      const minX = Math.min(...scatterData.points.map((p) => p.x));
      const maxY = Math.max(...scatterData.points.map((p) => p.y));
      const minY = Math.min(...scatterData.points.map((p) => p.y));

      ctx.fillStyle = corr.color + "66"; // Add transparency
      scatterData.points.forEach((point) => {
        const x = padding.left + ((point.x - minX) / (maxX - minX)) * width;
        const y =
          padding.top + height - ((point.y - minY) / (maxY - minY)) * height;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, 2 * Math.PI);
        ctx.fill();
      });

      // Draw trend line if available
      if (scatterData.trend_line) {
        ctx.strokeStyle = corr.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        const x1 = padding.left;
        const x2 = padding.left + width;
        const y1 =
          padding.top +
          height -
          ((scatterData.trend_line.y1 - minY) / (maxY - minY)) * height;
        const y2 =
          padding.top +
          height -
          ((scatterData.trend_line.y2 - minY) / (maxY - minY)) * height;
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    }
  });
}

// Populate similarity matrix from data
function populateSimilarityMatrix() {
  const container = document.getElementById("similarity-matrix-container");
  if (!container || !window.analysisData || !window.analysisData.similarity) {
    return;
  }

  const data = window.analysisData.similarity;

  // Clear existing content
  container.innerHTML = "";

  // Set up grid columns
  const numCols = data.labels.length + 1; // +1 for header column
  container.style.gridTemplateColumns = `100px repeat(${data.labels.length}, 1fr)`;

  // Add empty top-left cell
  const emptyCell = document.createElement("div");
  emptyCell.className = "matrix-cell";
  container.appendChild(emptyCell);

  // Add header row
  data.labels.forEach((label) => {
    const cell = document.createElement("div");
    cell.className = "matrix-cell font-normal";
    // Handle i18n for "Period X" labels
    if (label.startsWith("Period ")) {
      const num = label.substring(7);
      cell.textContent = `Period ${num}`;
    } else {
      cell.textContent = label;
    }
    container.appendChild(cell);
  });

  // Add data rows
  data.matrix.forEach((row, rowIndex) => {
    // Add row header
    const rowHeader = document.createElement("div");
    rowHeader.className = "matrix-cell text-right font-normal";
    const label = data.labels[rowIndex];
    if (label.startsWith("Period ")) {
      const num = label.substring(7);
      rowHeader.textContent = `Period ${num}`;
    } else {
      rowHeader.textContent = label;
    }
    container.appendChild(rowHeader);

    // Add data cells
    row.forEach((cellData) => {
      const cell = document.createElement("div");
      cell.className = `matrix-cell intensity-${cellData.intensity}`;
      cell.textContent = cellData.display;
      container.appendChild(cell);
    });
  });

  // Update subtitle with period info if available
  if (data.period_info) {
    const subtitle = document.getElementById("similarity-subtitle");
    if (subtitle) {
      subtitle.innerHTML = `Jaccard similarity coefficients between time periods · Values shown as percentages for similarity >50%<br>
        <span class="text-xs">Comparing ${data.period_info.count} periods of ${data.period_info.size_days} days each · Total period: ${data.period_info.total_days} days</span>`;
    }
  }
}

// Export functions for global access if needed
window.drawDiversityTimeline = drawDiversityTimeline;
window.drawActivityHeatmap = drawActivityHeatmap;
window.drawTemporalChart = drawTemporalChart;
window.drawConfidenceChart = drawConfidenceChart;
window.drawSpeciesChart = drawSpeciesChart;
window.drawAccumulationCurve = drawAccumulationCurve;
window.drawBetaDiversity = drawBetaDiversity;
window.drawWeatherCorrelations = drawWeatherCorrelations;
window.populateSimilarityMatrix = populateSimilarityMatrix;
